[
  {
    "objectID": "posts/uefi-secure-boot/index.html",
    "href": "posts/uefi-secure-boot/index.html",
    "title": "UEFI Secure Boot",
    "section": "",
    "text": "Following this tutorial, I have successfully enrolled my own certificate for self-signing the OpenCore bootloader to support Secure Boot.\nLetâ€™s explore what happens when you sign an UEFI image. I recommend using an Ubuntu VM to have access to sbsign tool for UEFI development so you can follow the below commands:\n# Download opencore so you can get a clean unsigned UEFI application (You can use any .efi app so it doesn't have to be OpenCore)\ncurl -L https://github.com/acidanthera/OpenCorePkg/releases/download/0.8.3/OpenCore-0.8.3-RELEASE.zip > opencore.zip\nunzip opencore.zip -d opencore\n\n# Generate an Image Signing Key (ISK) using openSSL\nopenssl req -new -x509 -newkey rsa:2048 -sha256 -days 365 -subj \"/CN=Image Signing Key\" -keyout ISK.key -out ISK.pem\n# Using sbsign to sign the image. This app is part of sbsigntools\nsbsign --key ISK.key --cert ISK.pem opencore/X64/EFI/BOOT/BOOTx64.efi --output opencore/X64/EFI/BOOT/BOOTx64_signed.efi\nWe can run the following Python code to see the file size differences:\n\n\nCode\n# Print file size of unsigned and signed image\n\nwith open(\"opencore/X64/EFI/BOOT/BOOTx64.efi\", mode=\"rb\") as file:  # b is important -> binary\n    unsigned_image = file.read()\n    print(\"Unsigned image file size :\", len(unsigned_image))\n\nwith open(\"opencore/X64/EFI/BOOT/BOOTx64_signed.efi\", mode=\"rb\") as file:  # b is important -> binary\n    signed_image = file.read()\n    print(\"Signed image file size :\", len(signed_image))\n\n\nUnsigned image file size : 20484\nSigned image file size : 22056\n\n\nAs we can see the signed image increased by 1572 Bytes. This is because the signature is added to the original image. Now we will try to extract the signed certificate from the signed image. The UEFI image uses a Microsoft PE file system as described here. We can extract the certificate using the following steps:\n\nLocate the PE header by finding PE header offset from 0x3C file offset\nRead Optional Header immediate after the PE header to read the Magic code to determine offset for PE vs PE+ to get to the Certificate Table\nExtract each certificate by assuming the first certificate will start at the Certificate Table VirtualAddress. Then the next certificate will be 8-byte aligned from the end of the previous certificate. We will loop until the offset exceed the Certificate Table VirtualAddress + Size.\n\n\n\nCode\n# per microsoft PE/COFF spec, the first 4 bytes at 0x3c offset will point to the start of the PE header\npe_header = signed_image[0x3C : 0x3C + 4]\npe_header_offset = int.from_bytes(pe_header, \"little\") + 4\nprint(\"pe header offset :\", pe_header_offset)\n\n# Decode PE header\nimport ctypes\nclass PE_header(ctypes.Structure):\n    _fields_ = (\n        (\"Machine\", ctypes.c_uint16),\n        (\"NumberOfSections\", ctypes.c_uint16),\n        (\"TimeDateStamp\", ctypes.c_uint32),\n        (\"PointerToSymbolTable\", ctypes.c_uint32),\n        (\"NumberOfSymbols\", ctypes.c_uint32),\n        (\"SizeOfOptionalHeader\", ctypes.c_uint16),\n        (\"Characteristics\", ctypes.c_uint16),\n    )\n\nraw_pe_header = signed_image[pe_header_offset : pe_header_offset + ctypes.sizeof(PE_header)]\npe_header = PE_header.from_buffer_copy(raw_pe_header)\n\n# Print PE header\nprint(\"PE header info: \")\nprint(\"\\tMachine :\", hex(pe_header.Machine))\nprint(\"\\tNumberOfSections :\", pe_header.NumberOfSections)\nprint(\"\\tTimeDateStamp :\", pe_header.TimeDateStamp)\nprint(\"\\tPointerToSymbolTable :\", pe_header.PointerToSymbolTable)\nprint(\"\\tNumberOfSymbols :\", pe_header.NumberOfSymbols)\nprint(\"\\tSizeOfOptionalHeader :\", pe_header.SizeOfOptionalHeader)\nprint(\"\\tCharacteristics :\", hex(pe_header.Characteristics))\n\n\n# Decode Magic from optional header\n\nraw_optional_header = signed_image[\n    pe_header_offset\n    + ctypes.sizeof(PE_header) : pe_header_offset\n    + ctypes.sizeof(PE_header)\n    + pe_header.SizeOfOptionalHeader\n]\nmagic = raw_optional_header[0:2]\n\n\nif magic == b\"\\x0b\\x01\":\n    print(\"Found a PE32 image\")\n    cert_table_offset = 128\nelif magic == b\"\\x0b\\x02\":\n    print(\"Found a PE32+ image\")\n    cert_table_offset = 144\nelse:\n    print(\"Unknown PE magic\")\n    exit()\nraw_cert_table = raw_optional_header[cert_table_offset : cert_table_offset + 8]\n\n# Decode Optional Header Data Directory to get certificates\nclass DATA_Directory(ctypes.Structure):\n    _fields_ = (\n        (\"VirtualAddress\", ctypes.c_uint32),\n        (\"Size\", ctypes.c_uint32),\n    )\n# Optional Header Data Directory contains start of Cert address and total size of all certs\ncert_table = DATA_Directory.from_buffer_copy(raw_cert_table)\nprint(\"\\nCertificate Table VirtualAddress:\", cert_table.VirtualAddress)\nprint(\"Certificate Table Size:\", cert_table.Size)\n\n\npe header offset : 132\nPE header info: \n    Machine : 0x8664\n    NumberOfSections : 2\n    TimeDateStamp : 0\n    PointerToSymbolTable : 20480\n    NumberOfSymbols : 0\n    SizeOfOptionalHeader : 240\n    Characteristics : 0x30e\nFound a PE32+ image\n\nCertificate Table VirtualAddress: 20488\nCertificate Table Size: 1568\n\n\nWe found the Certificate Table starts at offset 20488 with a size of 1568 bytes. Now we can write our loop to read all certificates:\n\n\nCode\n# walk to cert table\n\nclass Cert_Attribute(ctypes.Structure):\n    _fields_ = (\n        (\"dwLength\", ctypes.c_uint32),\n        (\"wRevision\", ctypes.c_uint16),\n        (\"wCertificateType\", ctypes.c_uint16),\n    )\n\noffset = 0\ncerts = []\nwhile offset < cert_table.Size:\n    print(\"Cerificate at relative offset:\", offset)\n    raw_cert = signed_image[\n        cert_table.VirtualAddress\n        + offset : cert_table.VirtualAddress\n        + offset\n        + ctypes.sizeof(Cert_Attribute)\n    ]\n    cert = Cert_Attribute.from_buffer_copy(raw_cert)\n    print(\"\\tcert.dwLength\", cert.dwLength)\n    print(\"\\tcert.wRevision\", cert.wRevision)\n    print(\"\\tcert.wCertificateType\", cert.wCertificateType)\n    print(\"\\tCert attribute len: \", ctypes.sizeof(Cert_Attribute))\n    pcks = signed_image[\n        cert_table.VirtualAddress\n        + offset\n        + ctypes.sizeof(Cert_Attribute) : cert_table.VirtualAddress\n        + offset\n        + ctypes.sizeof(Cert_Attribute)\n        + cert.dwLength \n    ]\n    certs.append(pcks)\n    pad_len = (8 - ((offset + cert.dwLength) % 8)) % 8\n    offset += ctypes.sizeof(Cert_Attribute) + cert.dwLength + pad_len\n    print(\"\\tNext offset in cert table: \", offset)\n\nprint(\"We found a total of : \", len(certs), \"certificate(s)\")\n\n\nCerificate at relative offset: 0\n    cert.dwLength 1561\n    cert.wRevision 512\n    cert.wCertificateType 2\n    Cert attribute len:  8\n    Next offset in cert table:  1576\nWe found a total of :  1 certificate(s)\n\n\nOnce we have the certificate then we want to store it as a binary file in order to use openSSL lib to extract cert information and perform signature verification.\n\n\nCode\n# Write cert to file\nfor i,c in enumerate(certs):\n    # write c as a binary file\n    with open(f\"image_cert_{i}.bin\", mode=\"wb\") as file:  # b is important -> binary\n        file.write(c)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Personal Blog",
    "section": "",
    "text": "Secure Boot\n\n\nUEFI\n\n\nEDK2\n\n\nopenSSL\n\n\n\n\n\n\n\n\n\n\n\nSep 1, 2022\n\n\nPeter Pham\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  }
]