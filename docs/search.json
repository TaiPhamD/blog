[
  {
    "objectID": "posts/uefi-secure-boot/index.html",
    "href": "posts/uefi-secure-boot/index.html",
    "title": "UEFI Secure Boot",
    "section": "",
    "text": "Following this tutorial, I have successfully enrolled my own certificate for self-signing the OpenCore bootloader to support Secure Boot.\nLetâ€™s explore what happens when you sign an UEFI image. I recommend using an Ubuntu VM to have access to sbsign tool for UEFI development so you can follow the below commands:\n# Download opencore so you can get a clean unsigned UEFI application (You can use any .efi app so it doesn't have to be OpenCore)\ncurl -L https://github.com/acidanthera/OpenCorePkg/releases/download/0.8.3/OpenCore-0.8.3-RELEASE.zip > opencore.zip\nunzip opencore.zip -d opencore\n\n# Generate an Image Signing Key (ISK) using openSSL\nopenssl req -new -x509 -newkey rsa:2048 -sha256 -days 365 -subj \"/CN=Image Signing Key\" -keyout ISK.key -out ISK.pem\n# Using sbsign to sign the image. This app is part of sbsigntools\nsbsign --key ISK.key --cert ISK.pem opencore/X64/EFI/BOOT/BOOTx64.efi --output opencore/X64/EFI/BOOT/BOOTx64_signed.efi\nWe can run the following Python code to see the file size differences:\n\n\nCode\n# Print file size of unsigned and signed image\n\nwith open(\"opencore/X64/EFI/BOOT/BOOTx64.efi\", mode=\"rb\") as file:  # b is important -> binary\n    unsigned_image = file.read()\n    print(\"Unsigned image file size :\", len(unsigned_image))\n\nwith open(\"opencore/X64/EFI/BOOT/BOOTx64_signed.efi\", mode=\"rb\") as file:  # b is important -> binary\n    signed_image = file.read()\n    print(\"Signed image file size :\", len(signed_image))\n\n\nUnsigned image file size : 20484\nSigned image file size : 22056\n\n\nAs we can see the signed image increased by 1572 Bytes. This is because the signature is added to the original image. Now we will try to extract the signed certificate from the signed image. The UEFI image uses a Microsoft PE file system as described here. We can extract the certificate using the following steps:\n\nLocate the PE header by finding PE header offset from 0x3C file offset\nRead Optional Header immediate after the PE header to read the Magic code to determine offset for PE vs PE+ to get to the Certificate Table\nExtract each certificate by assuming the first certificate will start at the Certificate Table VirtualAddress. Then the next certificate will be 8-byte aligned from the end of the previous certificate. We will loop until the offset exceeds the Certificate Table Size.\n\n\n\nCode\n# per microsoft PE/COFF spec, the first 4 bytes at 0x3c offset will point to the start of the PE header\npe_header = signed_image[0x3C : 0x3C + 4]\npe_header_offset = int.from_bytes(pe_header, \"little\") + 4\nprint(\"pe header offset :\", pe_header_offset)\n\n# Decode PE header\nimport ctypes\nclass PE_header(ctypes.Structure):\n    _fields_ = (\n        (\"Machine\", ctypes.c_uint16),\n        (\"NumberOfSections\", ctypes.c_uint16),\n        (\"TimeDateStamp\", ctypes.c_uint32),\n        (\"PointerToSymbolTable\", ctypes.c_uint32),\n        (\"NumberOfSymbols\", ctypes.c_uint32),\n        (\"SizeOfOptionalHeader\", ctypes.c_uint16),\n        (\"Characteristics\", ctypes.c_uint16),\n    )\n\nraw_pe_header = signed_image[pe_header_offset : pe_header_offset + ctypes.sizeof(PE_header)]\npe_header = PE_header.from_buffer_copy(raw_pe_header)\n\n# Print PE header\nprint(\"PE header info: \")\nprint(\"\\tMachine :\", hex(pe_header.Machine))\nprint(\"\\tNumberOfSections :\", pe_header.NumberOfSections)\nprint(\"\\tTimeDateStamp :\", pe_header.TimeDateStamp)\nprint(\"\\tPointerToSymbolTable :\", pe_header.PointerToSymbolTable)\nprint(\"\\tNumberOfSymbols :\", pe_header.NumberOfSymbols)\nprint(\"\\tSizeOfOptionalHeader :\", pe_header.SizeOfOptionalHeader)\nprint(\"\\tCharacteristics :\", hex(pe_header.Characteristics))\n\n\n# Decode Magic from optional header\n\nraw_optional_header = signed_image[\n    pe_header_offset\n    + ctypes.sizeof(PE_header) : pe_header_offset\n    + ctypes.sizeof(PE_header)\n    + pe_header.SizeOfOptionalHeader\n]\nmagic = raw_optional_header[0:2]\n\n\nif magic == b\"\\x0b\\x01\":\n    print(\"Found a PE32 image\")\n    cert_table_offset = 128\nelif magic == b\"\\x0b\\x02\":\n    print(\"Found a PE32+ image\")\n    cert_table_offset = 144\nelse:\n    print(\"Unknown PE magic\")\n    exit()\nraw_cert_table = raw_optional_header[cert_table_offset : cert_table_offset + 8]\n\n# Decode Optional Header Data Directory to get certificates\nclass DATA_Directory(ctypes.Structure):\n    _fields_ = (\n        (\"VirtualAddress\", ctypes.c_uint32),\n        (\"Size\", ctypes.c_uint32),\n    )\n# Optional Header Data Directory contains start of Cert address and total size of all certs\ncert_table = DATA_Directory.from_buffer_copy(raw_cert_table)\nprint(\"\\nCertificate Table VirtualAddress:\", cert_table.VirtualAddress)\nprint(\"Certificate Table Size:\", cert_table.Size)\n\n\npe header offset : 132\nPE header info: \n    Machine : 0x8664\n    NumberOfSections : 2\n    TimeDateStamp : 0\n    PointerToSymbolTable : 20480\n    NumberOfSymbols : 0\n    SizeOfOptionalHeader : 240\n    Characteristics : 0x30e\nFound a PE32+ image\n\nCertificate Table VirtualAddress: 20488\nCertificate Table Size: 1568\n\n\nWe found the Certificate Table starts at offset 20488 with a size of 1568 bytes. Now we can write our loop to read all certificates:\n\n\nCode\n# walk to cert table\n\nclass Cert_Attribute(ctypes.Structure):\n    _fields_ = (\n        (\"dwLength\", ctypes.c_uint32),\n        (\"wRevision\", ctypes.c_uint16),\n        (\"wCertificateType\", ctypes.c_uint16),\n    )\n\noffset = 0\ncerts = []\nwhile offset < cert_table.Size:\n    print(\"Cerificate at relative offset:\", offset)\n    raw_cert = signed_image[\n        cert_table.VirtualAddress\n        + offset : cert_table.VirtualAddress\n        + offset\n        + ctypes.sizeof(Cert_Attribute)\n    ]\n    cert = Cert_Attribute.from_buffer_copy(raw_cert)\n    print(\"\\tcert.dwLength\", cert.dwLength)\n    print(\"\\tcert.wRevision\", cert.wRevision)\n    print(\"\\tcert.wCertificateType\", cert.wCertificateType)\n    print(\"\\tCert attribute len: \", ctypes.sizeof(Cert_Attribute))\n    pcks = signed_image[\n        cert_table.VirtualAddress\n        + offset\n        + ctypes.sizeof(Cert_Attribute) : cert_table.VirtualAddress\n        + offset\n        + ctypes.sizeof(Cert_Attribute)\n        + cert.dwLength \n    ]\n    certs.append(pcks)\n    pad_len = (8 - ((offset + cert.dwLength) % 8)) % 8\n    offset += ctypes.sizeof(Cert_Attribute) + cert.dwLength + pad_len\n    print(\"\\tNext offset in cert table: \", offset)\n\nprint(\"We found a total of : \", len(certs), \"certificate(s)\")\n\n\nCerificate at relative offset: 0\n    cert.dwLength 1561\n    cert.wRevision 512\n    cert.wCertificateType 2\n    Cert attribute len:  8\n    Next offset in cert table:  1576\nWe found a total of :  1 certificate(s)\n\n\nOnce we have the certificate then we can parse the certificate using pyasn1 module.\n\n\nCode\n# See also https://github.com/etingof/pyasn1-modules/blob/master/tools/pkcs7dump.py\nfrom pyasn1.codec.der import decoder, encoder\nfrom pyasn1_modules import rfc2315 # PKCS#7\nfrom pyasn1_modules import rfc2459 # X.509\nfrom pyasn1_modules import rfc2437 # PKCS#1 (RSA)\nfrom cryptography.hazmat.primitives.asymmetric import rsa, padding, utils\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography import x509\nimport hashlib\n# Parse just the first cert\nc = certs[0]\n# Extract the content field\nprint(\"Decoding certificate\\n\")\ncontent_info, _ = decoder.decode(c, asn1Spec=rfc2315.ContentInfo())\nprint(\"contentType: \", content_info.getComponentByName(\"contentType\"))\n# Decode the content as signed_data\nsigned_data, _ = decoder.decode(content_info.getComponentByName(\"content\"), asn1Spec=rfc2315.SignedData())\nprint(signed_data[\"contentInfo\"])\nprint(signed_data[\"signerInfos\"])\n\n\nDecoding certificate\n\ncontentType:  1.2.840.113549.1.7.2\nContentInfo:\n contentType=1.3.6.1.4.1.311.2.1.4\n content=0x30683033060a2b06010401823702010f3025030100a020a21e801c003c003c003c004f00620073006f006c006500740065003e003e003e3031300d0609608648016503040201050004204fa815e765a5c1f35d789a11c8d9cbaf382bc3cd947641ac28b54a73f1bc3846\n\nSignerInfos:\n SignerInfo:\n  version=1\n  issuerAndSerialNumber=IssuerAndSerialNumber:\n   issuer=Name:\n    =RDNSequence:\n     RelativeDistinguishedName:\n      AttributeTypeAndValue:\n       type=2.5.4.3\n       value=0x0c11496d616765205369676e696e67204b6579\n\n\n   serialNumber=564786507814499166980799104914873632846554102714\n\n  digestAlgorithm=DigestAlgorithmIdentifier:\n   algorithm=2.16.840.1.101.3.4.2.1\n   parameters=0x0500\n\n  authenticatedAttributes=Attributes:\n   Attribute:\n    type=1.2.840.113549.1.9.3\n    values=SetOf:\n     0x060a2b060104018237020104\n   Attribute:\n    type=1.2.840.113549.1.9.5\n    values=SetOf:\n     0x170d3232303930313138353034345a\n   Attribute:\n    type=1.2.840.113549.1.9.4\n    values=SetOf:\n     0x0420d68710d0a0a800b0f7a8bf951fa86cd333955b9c742e1c65a187a89156149a5b\n   Attribute:\n    type=1.2.840.113549.1.9.15\n    values=SetOf:\n     0x306a300b060960864801650304012a300b0609608648016503040116300b0609608648016503040102300a06082a864886f70d0307300e06082a864886f70d030202020080300d06082a864886f70d0302020140300706052b0e030207300d06082a864886f70d0302020128\n\n  digestEncryptionAlgorithm=DigestEncryptionAlgorithmIdentifier:\n   algorithm=1.2.840.113549.1.1.1\n   parameters=0x0500\n\n  encryptedDigest=0x3b845b6a449abf57fa93282bb9e95be907e9ea6bfbc5ae16457019ef12fe1346b718d5eb3800fcd3425e5cfd0812b191addc064201472a6a6d56312c372882f9c4ed1aeb95bdf548f78444008141ba7a3e0a86653ea859ce3228e956aaa2209b7ccb14714ee26ee12668c8d26d22e3ec219acd0f56f6ea23a9358a47c48dd26146acc8015e8af5cdc8c1c7dce9b035dbd024d14304e335a5373cb0f72b642208594553c9996967df5ed33b0257a875b264861002e233dc90ec43f12cdee94fcf467bb43087a0b50ff783e0b2a8a11bd71e47f62160a4e92c400f436a4337cf6887c65ca768b61e040caa79c219076a009eb6953efcce62a0b386685f6489b700\n\n\n\nThere are several steps in the UEFI image verification process but we will just go over 2 of them:\n\nCompute the hash of the PE image per MS specification\nCompute the sha256 of the authenticatedAttributes (rfc2315). Then encode it with our private key to get the computed encoded digest. This computed encoded digest should match the encryptedDigest hex string in the certificate.\n\nNext we can manually compute the sha256 hash of the rfc2315 authenticatedAttributes:\n\n\nCode\n# Extract authenticatedAttributes\nauthenticated_attributes_orig = signed_data[\"signerInfos\"][0][\"authenticatedAttributes\"]\n# Get rid of the implicit tag authenticatedAttributes (it's not supposed to be included in the signature)\nauthenticated_attributes = rfc2315.Attributes()\nauthenticated_attributes.extend(authenticated_attributes_orig)\nprint(authenticated_attributes)\nauth_attr_raw = encoder.encode(authenticated_attributes)\ndigest = hashlib.sha256(auth_attr_raw).digest()\nprint(\"SHA256 of authenticated_attributes: \", rfc2315.Digest(digest).prettyPrint())\n\n\nAttributes:\n Attribute:\n  type=1.2.840.113549.1.9.3\n  values=SetOf:\n   0x060a2b060104018237020104\n Attribute:\n  type=1.2.840.113549.1.9.5\n  values=SetOf:\n   0x170d3232303930313138353034345a\n Attribute:\n  type=1.2.840.113549.1.9.4\n  values=SetOf:\n   0x0420d68710d0a0a800b0f7a8bf951fa86cd333955b9c742e1c65a187a89156149a5b\n Attribute:\n  type=1.2.840.113549.1.9.15\n  values=SetOf:\n   0x306a300b060960864801650304012a300b0609608648016503040116300b0609608648016503040102300a06082a864886f70d0307300e06082a864886f70d030202020080300d06082a864886f70d0302020140300706052b0e030207300d06082a864886f70d0302020128\n\nSHA256 of authenticated_attributes:  0x2be480abe73ef6ed7b6216cddbc24a0aef671d56c263aecdfbb2c39ad289339c"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Personal Blog",
    "section": "",
    "text": "Secure Boot\n\n\nUEFI\n\n\nEDK2\n\n\nopenSSL\n\n\n\n\n\n\n\n\n\n\n\nSep 1, 2022\n\n\nPeter Pham\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  }
]