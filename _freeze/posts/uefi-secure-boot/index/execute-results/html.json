{
  "hash": "e273cb02f60729e6fd6d6c732c6bbffb",
  "result": {
    "markdown": "---\ntitle: UEFI Secure Boot\nauthor: Peter Pham\ndate: '2022-09-01'\ncategories:\n  - Secure Boot\n  - UEFI\n  - EDK2\n  - openSSL\nimage: uefi_logo.png\nformat:\n  html:\n    code-fold: true\n---\n\nSecure Boot has becoming more popular in the past few years in the consumer PC segment due to the new windows 11 [Secure Boot requirement](https://www.windowscentral.com/how-enable-secure-boot-pc-install-windows-11). I wanted to learn more about Secure Boot by implementing part of UEFI security validation process using Python as proof of concept.\n\nFollowing this [tutorial](https://github.com/perez987/OpenCore-UEFI-Secure-Boot), I have successfully enrolled my own certificate for self-signing the [OpenCore](https://github.com/acidanthera/OpenCorePkg) bootloader to support Secure Boot. \n\nLet's explore what happens when you sign an UEFI image. I recommend using an Ubuntu VM to have access to [sbsign tool](https://manpages.ubuntu.com/manpages/xenial/man1/sbsign.1.html) for UEFI development so you can follow the below commands: \n\n```bash\n# Download opencore so you can get a clean unsigned UEFI application (You can use any .efi app so it doesn't have to be OpenCore)\ncurl -L https://github.com/acidanthera/OpenCorePkg/releases/download/0.8.3/OpenCore-0.8.3-RELEASE.zip > opencore.zip\nunzip opencore.zip -d opencore\n\n# Generate an Image Signing Key (ISK) using openSSL\nopenssl req -new -x509 -newkey rsa:2048 -sha256 -days 365 -subj \"/CN=Image Signing Key\" -keyout ISK.key -out ISK.pem\n# Using sbsign to sign the image. This app is part of sbsigntools\nsbsign --key ISK.key --cert ISK.pem opencore/X64/EFI/BOOT/BOOTx64.efi --output opencore/X64/EFI/BOOT/BOOTx64_signed.efi\n```\n\nWe can run the following Python code to see the file size differences:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# Print file size of unsigned and signed image\n\nwith open(\"opencore/X64/EFI/BOOT/BOOTx64.efi\", mode=\"rb\") as file:  # b is important -> binary\n    unsigned_image = file.read()\n    print(\"Unsigned image file size :\", len(unsigned_image))\n\nwith open(\"opencore/X64/EFI/BOOT/BOOTx64_signed.efi\", mode=\"rb\") as file:  # b is important -> binary\n    signed_image = file.read()\n    print(\"Signed image file size :\", len(signed_image))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnsigned image file size : 20484\nSigned image file size : 22056\n```\n:::\n:::\n\n\nAs we can see the signed image increased by 1572 Bytes. This is because the signature is added to the original image. Now we will try to extract the signed certificate from the signed image. The UEFI image uses a Microsoft PE file system as described [here](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format). We can extract the certificate using the following steps:\n\n  - Locate the PE header by finding PE header offset from **0x3C** file offset\n  - Read Optional Header immediate after the PE header to read the **Magic** code to determine offset for PE vs PE+ to get to the **Certificate Table**\n  - Extract each certificate by assuming the first certificate will start at the Certificate Table VirtualAddress. Then the next certificate will be 8-byte aligned from the end of the previous certificate. We will loop until the offset exceed the Certificate Table VirtualAddress + Size.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# per microsoft PE/COFF spec, the first 4 bytes at 0x3c offset will point to the start of the PE header\npe_header = signed_image[0x3C : 0x3C + 4]\npe_header_offset = int.from_bytes(pe_header, \"little\") + 4\nprint(\"pe header offset :\", pe_header_offset)\n\n# Decode PE header\nimport ctypes\nclass PE_header(ctypes.Structure):\n    _fields_ = (\n        (\"Machine\", ctypes.c_uint16),\n        (\"NumberOfSections\", ctypes.c_uint16),\n        (\"TimeDateStamp\", ctypes.c_uint32),\n        (\"PointerToSymbolTable\", ctypes.c_uint32),\n        (\"NumberOfSymbols\", ctypes.c_uint32),\n        (\"SizeOfOptionalHeader\", ctypes.c_uint16),\n        (\"Characteristics\", ctypes.c_uint16),\n    )\n\nraw_pe_header = signed_image[pe_header_offset : pe_header_offset + ctypes.sizeof(PE_header)]\npe_header = PE_header.from_buffer_copy(raw_pe_header)\n\n# Print PE header\nprint(\"PE header info: \")\nprint(\"\\tMachine :\", hex(pe_header.Machine))\nprint(\"\\tNumberOfSections :\", pe_header.NumberOfSections)\nprint(\"\\tTimeDateStamp :\", pe_header.TimeDateStamp)\nprint(\"\\tPointerToSymbolTable :\", pe_header.PointerToSymbolTable)\nprint(\"\\tNumberOfSymbols :\", pe_header.NumberOfSymbols)\nprint(\"\\tSizeOfOptionalHeader :\", pe_header.SizeOfOptionalHeader)\nprint(\"\\tCharacteristics :\", hex(pe_header.Characteristics))\n\n\n# Decode Magic from optional header\n\nraw_optional_header = signed_image[\n    pe_header_offset\n    + ctypes.sizeof(PE_header) : pe_header_offset\n    + ctypes.sizeof(PE_header)\n    + pe_header.SizeOfOptionalHeader\n]\nmagic = raw_optional_header[0:2]\n\n\nif magic == b\"\\x0b\\x01\":\n    print(\"Found a PE32 image\")\n    cert_table_offset = 128\nelif magic == b\"\\x0b\\x02\":\n    print(\"Found a PE32+ image\")\n    cert_table_offset = 144\nelse:\n    print(\"Unknown PE magic\")\n    exit()\nraw_cert_table = raw_optional_header[cert_table_offset : cert_table_offset + 8]\n\n# Decode Optional Header Data Directory to get certificates\nclass DATA_Directory(ctypes.Structure):\n    _fields_ = (\n        (\"VirtualAddress\", ctypes.c_uint32),\n        (\"Size\", ctypes.c_uint32),\n    )\n# Optional Header Data Directory contains start of Cert address and total size of all certs\ncert_table = DATA_Directory.from_buffer_copy(raw_cert_table)\nprint(\"\\nCertificate Table VirtualAddress:\", cert_table.VirtualAddress)\nprint(\"Certificate Table Size:\", cert_table.Size)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npe header offset : 132\nPE header info: \n\tMachine : 0x8664\n\tNumberOfSections : 2\n\tTimeDateStamp : 0\n\tPointerToSymbolTable : 20480\n\tNumberOfSymbols : 0\n\tSizeOfOptionalHeader : 240\n\tCharacteristics : 0x30e\nFound a PE32+ image\n\nCertificate Table VirtualAddress: 20488\nCertificate Table Size: 1568\n```\n:::\n:::\n\n\nWe found the Certificate Table starts at offset 20488 with a size of 1568 bytes. Now we can write our loop to read all certificates:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# walk to cert table\n\nclass Cert_Attribute(ctypes.Structure):\n    _fields_ = (\n        (\"dwLength\", ctypes.c_uint32),\n        (\"wRevision\", ctypes.c_uint16),\n        (\"wCertificateType\", ctypes.c_uint16),\n    )\n\noffset = 0\ncerts = []\nwhile offset < cert_table.Size:\n    print(\"Cerificate at relative offset:\", offset)\n    raw_cert = signed_image[\n        cert_table.VirtualAddress\n        + offset : cert_table.VirtualAddress\n        + offset\n        + ctypes.sizeof(Cert_Attribute)\n    ]\n    cert = Cert_Attribute.from_buffer_copy(raw_cert)\n    print(\"\\tcert.dwLength\", cert.dwLength)\n    print(\"\\tcert.wRevision\", cert.wRevision)\n    print(\"\\tcert.wCertificateType\", cert.wCertificateType)\n    print(\"\\tCert attribute len: \", ctypes.sizeof(Cert_Attribute))\n    pcks = signed_image[\n        cert_table.VirtualAddress\n        + offset\n        + ctypes.sizeof(Cert_Attribute) : cert_table.VirtualAddress\n        + offset\n        + ctypes.sizeof(Cert_Attribute)\n        + cert.dwLength \n    ]\n    certs.append(pcks)\n    pad_len = (8 - ((offset + cert.dwLength) % 8)) % 8\n    offset += ctypes.sizeof(Cert_Attribute) + cert.dwLength + pad_len\n    print(\"\\tNext offset in cert table: \", offset)\n\nprint(\"We found a total of : \", len(certs), \"certificate(s)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCerificate at relative offset: 0\n\tcert.dwLength 1561\n\tcert.wRevision 512\n\tcert.wCertificateType 2\n\tCert attribute len:  8\n\tNext offset in cert table:  1576\nWe found a total of :  1 certificate(s)\n```\n:::\n:::\n\n\nOnce we have the certificate then we want to store it as a binary file in order to use openSSL lib to extract cert information and perform signature verification.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Write cert to file\nfor i,c in enumerate(certs):\n    # write c as a binary file\n    with open(f\"image_cert_{i}.bin\", mode=\"wb\") as file:  # b is important -> binary\n        file.write(c)\n```\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}